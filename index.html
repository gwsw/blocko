<!doctype html>
<meta charset="UTF-8">
<html>
<head>
<title>Blocko</title>
</head>
<body onload="main()">
<canvas id="canvas" width="1" height="1" style="font-family:Arial"></canvas>
<script>

// --------------------------------------------------------------------
// Globals
var _game = null;
var _square_size;

var config = {
    cell_margin                 : 2,
    score_margin                : 2,
    board_margin                : 8,
    square_gap                  : 1,
    score_fracof_board          : .75,
    score_height_fracof_board   : .12,
    score_y_fracof_height       : .12,
    score_y_fracof_height       : .75,
    board_space_fracof_score_height : .20,

    color_canvas_bg             : "00e0e0",
    color_board_bg              : "101830",
    color_board_bg_margin       : "808080",
    color_score_margin          : "202000",
    color_score_bg              : "c0c040",
    color_score_fg              : "000000",
    color_game_over_fg          : "ffffff",
    color_game_over_fg2         : "000000",
    color_tile_I                : "866122",
    color_tile_L                : "F00034",
    color_tile_Q                : "34CB33",
    color_tile_R                : "A129D6",
    color_tile_S                : "F1EC5F",
    color_tile_T                : "FB5B04",
    color_tile_Z                : "4693B8",
};

// --------------------------------------------------------------------
class Color {
    constructor(hex) {
        this.hex_str = hex;
    }
    hex() {
        return this.hex_str;
    }
    jstring() {
        return "#" + this.hex_str;
    }
    get_comp(comp) {
        return parseInt(this.hex_str.substr(comp*2, 2), 16);
    }
    darker(mult) {
        return new Color(hex2(this.get_comp(0)*mult) + hex2(this.get_comp(1)*mult) + hex2(this.get_comp(2)*mult));
    }
};

// --------------------------------------------------------------------
class Graphics {
    constructor(ctx, font_size) {
        this.ctx = ctx;
        ctx.font = Math.floor(font_size).toString()+"px sans-serif";
        this.font_height = font_size;
    }
    clear(color) {
        const canvas = this.ctx.canvas;
        const w = canvas.width;
        const h = canvas.height;
        this.ctx.clearRect(0, 0, w, h);
        this.draw_rect(0, 0, w, h, color);
    }
    draw_rect(x, y, w, h, color) {
        if (color != undefined && color != null)
            this.ctx.fillStyle = color.jstring();
        this.ctx.fillRect(x, y, w, h);
    }
    draw_centered_rect(cx, cy, w, h, color) {
        this.draw_rect(cx - w/2, cy - h/2, w, h, color);
    }
    draw_outline(x, y, w, h, xb, yb, color) {
        this.draw_rect(x,      y,       w-xb,   yb,   color);
        this.draw_rect(x+w-xb, y,       xb,     h-yb, color);
        this.draw_rect(x+xb,   y+h-yb,  w-xb,   yb,   color);
        this.draw_rect(x,      y+yb,    xb,     h-yb, color);
    }
    draw_centered_outline(cx, cy, w, h, xb, yb, color) {
        this.draw_outline(cx - w/2, cy - h/2, w, h, xb, yb, color);
    }
    draw_outlined_rect(x, y, w, h, xb, yb, bg_color, border_color) {
        this.draw_rect(x+xb, y+yb, w-2*xb, h-2*yb, bg_color);
        this.draw_outline(x, y, w, h, xb, yb, border_color);
    }
    draw_circle(x, y, r, color) {
        this.ctx.beginPath();
        this.ctx.fillStyle = color.jstring();
        this.ctx.arc(x, y, r, 0, 2*Math.PI);
        this.ctx.fill();
    }
    draw_text(x, y, text, color) {
        this.ctx.fillStyle = color.jstring();
        this.ctx.fillText(text, x, y+this.font_height);
    }
    measure_text(text) {
        let max_width = 0;
        let num_lines = 0;
        for (let line of text.split("\n")) {
            const text_size = this.ctx.measureText(line);
            if (text_size.width > max_width) max_width = text_size.width;
            ++num_lines;
        }
        return { width: max_width, height: this.font_height * num_lines };
    }
    // just < 0 => left justify
    // just > 0 => right justify
    // just == 0 => centered
    draw_just_text(x, y, w, text, just, color, color_shadow = null) {
        const text_size = this.measure_text(text);
        let nx = x;
        if (just == 0)
            nx = x + (w - text_size.width) / 2;
        else if (just > 0)
            nx = x + w - text_size.width;
        if (nx > x) x = nx;
        if (color_shadow != null) this.draw_text(x+2, y+2, text, color_shadow);
        this.draw_text(x, y, text, color);
        return text_size;
    }
    static end_word(text, p) {
        for (; p < text.length; ++p) {
            if (text.substr(p,1) != " ") break;
        }
        for (; p < text.length; ++p) {
            if (text.substr(p,1) == " " || text.substr(p,1) == "\n") break;
        }
        return p;
    }
    split_text(text, width) {
        let lines = [];
        let line = 0;
        for (;;) {
            // Skip spaces.
            while (text.substr(line,1) == " ")
                ++line;
            let end_line = line;
            // Output line starts here; step thru words.
            for (;;) {
                if (end_line >= text.length) {
                    if (end_line > line) lines.push(text.substr(line, end_line-line));
                    return lines;
                }
                const newline = (text.substr(end_line,1) == "\n");
                let e = -1;
                if (!newline) e = Graphics.end_word(text, end_line);
                if (newline || this.measure_text(text.substr(line, e-line)).width >= width) {
                    if (end_line == line && !newline) { // we must break a word
                        while (e > line && this.measure_text(text.substr(line, e-line)).width >= width)
                            e = e - 1;
                        end_line = e;
                    }
                    lines.push(text.substr(line, end_line-line));
                    line = end_line;
                    if (newline) ++line;
                    break;
                }
                end_line = e;
            }
        }
    }
    draw_paragraph(msg, x, y, w, color, center = false, list_char = "", dryrun = false) {
        const lines = this.split_text(msg, w);
        const line_h = this.font_height;
        const list_indent = (list_char.length == 0) ? 0 : this.measure_text(list_char).width;
        for (let i = 0; i < lines.length; ++i) {
            let line = lines[i];
            let tx = x;
            let center_line = center;
            if (line.substr(0,1) == "\t") {
                center_line = true;
                line = line.substr(1);
            }
            if (center_line) {
                const tw = this.measure_text(line).width;
                tx += Math.floor((w - tw) / 2);
            }
            if (list_char.length > 0 && line.substr(0,list_char.length) != list_char)
                tx += list_indent;
            if (!dryrun) this.draw_text(tx, y, line, color);
            y += line_h;
        }
        return { w: w, h: lines.length * line_h };
    }
    draw_vcentered_paragraph(msg, x, y, w, h, color, center = false, list_char = "") {
        const msg_size = this.measure_text(msg);
        y += (h - msg_size.height) / 2;
        return this.draw_paragraph(msg, x, y, w, color, center, list_char);
    }
}; // class Graphics

// --------------------------------------------------------------------
class Tile {
    static num_squares = 4;

    constructor(xpos, ypos) {
        const num_tile_types = 7;
        const tile_type = randu(num_tile_types);

        if (tile_type == 1) { // I
            this.squares = [ [-1,0], [0,0], [1,0], [2,0] ];
            this.color = config.color_tile_I;
        } else if (tile_type == 2) { // L
            this.squares = [ [-1,0], [0,0], [1,0], [-1,1] ];
            this.color = config.color_tile_L;
        } else if (tile_type == 3) { // R
            this.squares = [ [-1,0], [0,0], [1,0], [1,1] ];
            this.color = config.color_tile_R;
        } else if (tile_type == 4) { // Q
            this.squares = [ [0,0], [0,1], [1,0], [1,1] ];
            this.color = config.color_tile_Q;
        } else if (tile_type == 5) { // Z
            this.squares = [ [0,0], [1,0], [0,1], [-1,1] ];
            this.color = config.color_tile_Z;
        } else if (tile_type == 6) { // S
            this.squares = [ [0,0], [-1,0], [0,1], [1,1] ];
            this.color = config.color_tile_S;
        } else { // T
            this.squares = [ [0,0], [1,0], [-1,0], [0,1] ];
            this.color = config.color_tile_T;
        }
        this.xpos = xpos;
        this.ypos = ypos;
    }
    draw(gfx, xoff, yoff, dark = 1) {
        let color = this.color.darker(dark);
        for (let i = 0; i < Tile.num_squares; ++i)
            Tile.draw_square(gfx, xoff, yoff, this.xpos + this.squares[i][0], this.ypos + this.squares[i][1], color);
    }
    static draw_square(gfx, xoff, yoff, xpos, ypos, color) {
        const x = xoff + (xpos * _square_size);
        const y = yoff + (ypos * _square_size);
        gfx.draw_rect(x, y, _square_size-config.square_gap, _square_size-config.square_gap, color);
    }
    move(xincr, yincr) {
        this.xpos += xincr;
        this.ypos += yincr;
    }
    rotate(dir) {
        for (let i = 0; i < Tile.num_squares; ++i) {
            const t = this.squares[i][0];
            this.squares[i][0] = this.squares[i][1] * dir;
            this.squares[i][1] = -t * dir;
        }
    }
}; // class Tile

// --------------------------------------------------------------------
class Board {
    constructor(w, h) {
        this.width = w;
        this.height = h;
        this.cells = [];
        for (let ypos = 0; ypos < h; ++ypos) {
            this.cells.push([]);
            for (let xpos = 0; xpos < w; ++xpos) {
                this.cells[ypos].push(null);
            }
        }
    }
    clear_cells() {
        for (let ypos = 0; ypos < this.height; ++ypos) {
            for (let xpos = 0; xpos < this.width; ++xpos) {
                this.cells[ypos][xpos] = null;
            }
        }
    }
    fall_step(falling) {
        falling.move(0,1);
        if (!this.intersects(falling))
            return true;
        falling.move(0,-1);
        this.splat(falling);
        return false;
    }
    draw(gfx, cw, ch, dim) {
        const lo = this.layout(cw, ch);
        gfx.clear(config.canvas_bg);
        gfx.draw_outlined_rect(lo.board_x, lo.board_y, lo.board_width, lo.board_height, config.board_margin, config.board_margin, config.color_board_bg, config.color_board_bg_margin);
        for (let ypos = 0; ypos < this.height; ++ypos) {
            for (let xpos = 0; xpos < this.width; ++xpos) {
                let color = this.cells[ypos][xpos];
                if (color != null)
                    Tile.draw_square(gfx, lo.board_x + config.board_margin, lo.board_y + config.board_margin, xpos, ypos, color.darker(dim));
            }
        }
        return lo;
    }
    layout(cw, ch) {
        const lo = { cell_margin : config.cell_margin };
        lo.board_width = (_square_size * this.width) + (2*config.board_margin);
        lo.board_height = (_square_size * this.height) + (2*config.board_margin);
        lo.score_width = lo.board_width * config.score_fracof_board;
        lo.score_height = lo.board_height * config.score_height_fracof_board;
        lo.score_y = lo.score_height * config.score_y_fracof_height;
        lo.board_y = lo.score_y + lo.score_height * (1 + config.board_space_fracof_score_height);
        lo.score_x = (cw - lo.score_width) / 2;
        lo.board_x = (cw - lo.board_width) / 2;
        return lo;
    }
    check_full_rows() {
        let full_rows = 0;
        let full_row = [];
        for (let ypos = 0; ypos < this.height; ++ypos) {
            full_row.push(true); // full_row[ypos] = true;
            for (let xpos = 0; xpos < this.width; ++xpos) {
                if (this.cells[ypos][xpos] == null) {
                    full_row[ypos] = false;
                    break;
                }
            }
            if (full_row[ypos]) ++full_rows;
        }
        if (full_rows > 0) {
            let dst_y = this.height-1;
            for (let src_y = dst_y; src_y >= 0; --src_y) {
                if (!full_row[src_y]) {
                    for (let xpos = 0; xpos < this.width; ++xpos)
                        this.cells[dst_y][xpos] = this.cells[src_y][xpos];
                    --dst_y;
                }
            }
            while (dst_y > 0) {
                for (let xpos = 0; xpos < this.width; ++xpos) {
                    this.cells[dst_y][xpos] = null;
                }
                --dst_y;
            }
        }
        return full_rows;
    }
    intersects(tile) {
        for (let i = 0; i < Tile.num_squares; ++i) {
            const xpos = tile.xpos + tile.squares[i][0];
            const ypos = tile.ypos + tile.squares[i][1];
            if (xpos < 0 || xpos >= this.width) return true;
            if (ypos < 0 || ypos >= this.height) return true;
            if (this.cells[ypos][xpos] != null) return true;
        }
        return false;
    }
    splat(tile) {
        for (let i = 0; i < Tile.num_squares; ++i) {
            const xpos = tile.xpos + tile.squares[i][0];
            const ypos = tile.ypos + tile.squares[i][1];
            this.cells[ypos][xpos] = tile.color;
        }
    }
}; // class Board

// --------------------------------------------------------------------
class Game {
    constructor(gfx, w, h) {
        this.gfx = gfx;
        const canvas = gfx.ctx.canvas;
        this.canvas_size(canvas.width, canvas.height);
        this.num_explosions = 0;
        this.score_ = 0;
        this.falling = null;
        this.step_dur = 1000;
        this.last_step = 0;
        this.playing = true;
        this.game_over = false;
        this.board = new Board(w, h);
    }
    canvas_size(w, h) {
        this.cw = w;
        this.ch = h;
        _square_size  = h * .03;
    }
    run() {
        const old_explosions = this.explosions();
        if (this.playing) {
            const time = now();
            if (time >= this.last_step + this.step_dur) {
                this.game_step();
                this.last_step = time;
            }
        }
        this.draw(this.gfx);
        if (this.explosions() > old_explosions) {
            step_dur = (.9 * step_dur);
            if (step_dur < 110) step_dur = 110;
        }
    }
    game_step() {
        if (this.falling == null) {
            this.falling = new Tile(this.board.width/2, 1);
            if (this.board.intersects(this.falling))
                this.game_is_over();
        } else if (!this.board.fall_step(this.falling)) {
            this.falling = null;
            this.check_full_rows();
        }
    }
    draw(dur) {
        const dim = this.playing ? 1 : .45;
        const lo = this.board.draw(this.gfx, this.cw, this.ch, dim);

        if (this.falling != null)
            this.falling.draw(this.gfx, lo.board_x + config.board_margin, lo.board_y + config.board_margin, dim);

        const score_str = this.score_.toString();
        this.gfx.draw_outlined_rect(lo.score_x, lo.score_y, lo.score_width, lo.score_height, config.score_margin, config.score_margin, config.color_score_bg, config.color_score_margin);
        this.gfx.draw_just_text(lo.score_x + config.score_margin, lo.score_y + config.score_margin, lo.score_width*0.9, score_str, +1, config.color_score_fg);

        const msg_y = lo.board_y + config.board_margin*2;
        if (this.game_over)
            this.gfx.draw_just_text(lo.board_x, msg_y, lo.board_width, "Game over", 0, config.color_game_over_fg, config.color_game_over_fg2);
        else if (!this.playing)
            this.gfx.draw_just_text(lo.board_x, msg_y, lo.board_width, "PAUSED", 0, config.color_game_over_fg, config.color_game_over_fg2);
    }
    drop(gfx) {
        if (this.falling == null) return;
        while (this.falling != null) {
            this.game_step();
        }
        this.add_score(1);
    }
    move_horz(dir) {
        if (this.falling == null) return;
        this.falling.move(dir,0);
        if (this.board.intersects(this.falling))
            this.falling.move(-dir, 0);
    }
    rotate_falling() {
        if (this.falling == null) return;
        this.falling.rotate(1);
        if (this.board.intersects(this.falling))
            this.falling.rotate(-1);
    }
    explosions() {
        return this.num_explosions;
    }
    check_full_rows() {
        const full_rows = this.board.check_full_rows();
        if (full_rows > 0) {
            ++this.num_explosions;
            this.add_score(4 * full_rows*full_rows);
        }
    }
    score() {
        return this.score_;
    }
    add_score(incr) {
        const score_bloat = 25;
        this.score_ += incr * score_bloat;
    }
    static _event_keydown(e) {
        if (_game != null) _game.event_keystroke(e.key, true);
    }
    static _event_keyup(e) {
        if (_game != null) _game.event_keystroke(e.key, false);
    }
    event_keystroke(key, down) {
        if (!down) return;
        switch (key) {
        case 'ArrowDown':
            if (this.playing) this.drop();
            break;
        case 'ArrowRight':
            if (this.playing) this.move_horz(+1);
            break;
        case 'ArrowLeft':
            if (this.playing) this.move_horz(-1);
            break;
        case ' ': case 'Enter':
            if (this.playing) this.rotate_falling();
            break;
        case 'ArrowUp':
            this.playing = !this.playing;
            break;
        }
    }
    game_is_over() {
        this.falling = null;
        this.playing = false;
        this.game_over = true;
    }
}; // class Game

// --------------------------------------------------------------------

function now() {
    return performance.now();
}

function run_game() {
    if (_game != null) _game.run();
    window.requestAnimationFrame(run_game);
}

function munge_config() {
    for (const [key,value] of Object.entries(config)) {
        if (key.substr(0,6) == "color_")
            config[key] = new Color(config[key]);
    }
}

function el(name) {
    return document.getElementById(name);
}

function padnum(num, len, radix) {
    return Math.floor(num).toString(radix).padStart(len,"0");
}
function hex2(num) { return padnum(num, 2, 16); }

function randu(n) {
    return Math.floor(Math.random() * n);
}

function canvas_size(name, w, h) {
    const canvas = el(name);
    canvas.width = w;
    canvas.height = h;
    if (_game != null) _game.canvas_size(w, h);
    return canvas;
}

function canvas_resize() {
    const s = 20;
    return canvas_size("canvas", window.innerWidth - s, window.innerHeight - s);
}

function main() {
    munge_config();
    const canvas = canvas_resize();
    const gfx = new Graphics(canvas.getContext("2d"), canvas.height*.040);
    _game = new Game(gfx, 10, 20);
    document.addEventListener('keyup', Game._event_keyup);
    document.addEventListener('keydown', Game._event_keydown);
    window.addEventListener('resize', canvas_resize, false);
    run_game();
}

</script>
</body>
</html>
